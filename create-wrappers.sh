#!/bin/bash
# create-wrappers.sh - Create wrapper scripts for Rust and GCC binaries
# This script creates wrapper scripts that set up the proper environment
# for binaries without using patchelf, avoiding corruption issues.

set -euo pipefail

echo "Creating binary wrappers for RedoxOS build..."

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REDOX_ROOT="$SCRIPT_DIR"
WRAPPER_DIR="$REDOX_ROOT/wrappers"

# Ensure wrapper directory exists
mkdir -p "$WRAPPER_DIR"

# Find Rust toolchain in Nix store - prefer nightly
RUST_TOOLCHAIN_PATH=""
# First look for nightly
for path in /nix/store/*rust*nightly*; do
    if [[ -d "$path/bin" && -x "$path/bin/rustc" ]]; then
        RUST_TOOLCHAIN_PATH="$path"
        break
    fi
done
# Fallback to stable if no nightly found
if [[ -z "$RUST_TOOLCHAIN_PATH" ]]; then
    for path in /nix/store/*rust*; do
        if [[ -d "$path/bin" && -x "$path/bin/rustc" ]]; then
            RUST_TOOLCHAIN_PATH="$path"
            break
        fi
    done
fi

if [[ -z "$RUST_TOOLCHAIN_PATH" ]]; then
    echo "Error: Could not find Rust toolchain in Nix store"
    exit 1
fi

echo "Found Rust toolchain at: $RUST_TOOLCHAIN_PATH"

# Find GCC toolchain in Nix store
GCC_TOOLCHAIN_PATH=""
for path in /nix/store/*gcc-wrapper*; do
    if [[ -d "$path/bin" && -x "$path/bin/gcc" ]]; then
        GCC_TOOLCHAIN_PATH="$path"
        break
    fi
done

if [[ -z "$GCC_TOOLCHAIN_PATH" ]]; then
    # Try to find gcc without wrapper
    for path in /nix/store/*gcc*; do
        if [[ -d "$path/bin" && -x "$path/bin/gcc" ]]; then
            GCC_TOOLCHAIN_PATH="$path"
            break
        fi
    done
fi

echo "Found GCC toolchain at: ${GCC_TOOLCHAIN_PATH:-not found}"

# Build library paths for wrappers
build_library_paths() {
    local lib_paths=""

    # Rust library paths
    if [[ -d "$RUST_TOOLCHAIN_PATH/lib" ]]; then
        lib_paths="$RUST_TOOLCHAIN_PATH/lib:$lib_paths"
    fi

    if [[ -d "$RUST_TOOLCHAIN_PATH/lib/rustlib/x86_64-unknown-linux-gnu/lib" ]]; then
        lib_paths="$RUST_TOOLCHAIN_PATH/lib/rustlib/x86_64-unknown-linux-gnu/lib:$lib_paths"
    fi

    if [[ -d "$RUST_TOOLCHAIN_PATH/lib/rustlib/x86_64-unknown-redox/lib" ]]; then
        lib_paths="$RUST_TOOLCHAIN_PATH/lib/rustlib/x86_64-unknown-redox/lib:$lib_paths"
    fi

    # GCC library paths
    if [[ -n "$GCC_TOOLCHAIN_PATH" && -d "$GCC_TOOLCHAIN_PATH/lib" ]]; then
        lib_paths="$GCC_TOOLCHAIN_PATH/lib:$lib_paths"
    fi

    # System library paths from Nix
    for nix_path in /nix/store/*glibc*/lib /nix/store/*gcc*/lib; do
        if [[ -d "$nix_path" ]]; then
            lib_paths="$nix_path:$lib_paths"
        fi
    done

    # Add NIX_LD_LIBRARY_PATH if set
    if [[ -n "${NIX_LD_LIBRARY_PATH:-}" ]]; then
        lib_paths="$NIX_LD_LIBRARY_PATH:$lib_paths"
    fi

    # Add existing LD_LIBRARY_PATH
    if [[ -n "${LD_LIBRARY_PATH:-}" ]]; then
        lib_paths="$lib_paths:$LD_LIBRARY_PATH"
    fi

    # Remove trailing colon
    echo "${lib_paths%:}"
}

LIB_PATHS=$(build_library_paths)

# Function to create a wrapper script
create_wrapper() {
    local binary_name="$1"
    local real_binary_path="$2"
    local wrapper_path="$WRAPPER_DIR/$binary_name"

    echo "Creating wrapper for $binary_name -> $real_binary_path"

    cat > "$wrapper_path" << EOF
#!/bin/bash
# Wrapper for $binary_name - avoids binary patching issues
# Generated by create-wrappers.sh

# Set up library paths
export LD_LIBRARY_PATH="$LIB_PATHS"

# Set up Nix dynamic linker if available
if [[ -n "${NIX_LD:-}" ]]; then
    export LD_LIBRARY_PATH="\$NIX_LD_LIBRARY_PATH:\$LD_LIBRARY_PATH"
fi

# Execute the real binary with all arguments
exec "$real_binary_path" "\$@"
EOF

    chmod +x "$wrapper_path"
}

# Function to create a wrapper with specific environment
create_env_wrapper() {
    local binary_name="$1"
    local real_binary_path="$2"
    local wrapper_path="$WRAPPER_DIR/$binary_name"
    local extra_env="$3"

    echo "Creating environment wrapper for $binary_name -> $real_binary_path"

    cat > "$wrapper_path" << EOF
#!/bin/bash
# Environment wrapper for $binary_name
# Generated by create-wrappers.sh

# Set up library paths
export LD_LIBRARY_PATH="$LIB_PATHS"

# Set up Nix dynamic linker if available
if [[ -n "${NIX_LD:-}" ]]; then
    export LD_LIBRARY_PATH="\$NIX_LD_LIBRARY_PATH:\$LD_LIBRARY_PATH"
fi

# Extra environment setup
$extra_env

# Execute the real binary with all arguments
exec "$real_binary_path" "\$@"
EOF

    chmod +x "$wrapper_path"
}

echo ""
echo "Creating Rust toolchain wrappers..."

# Rust binaries to wrap
RUST_BINARIES=(
    "rustc"
    "cargo"
    "rustdoc"
    "rustfmt"
    "clippy-driver"
    "cargo-clippy"
    "rust-gdb"
    "rust-lldb"
    "cargo-fmt"
)

for binary in "${RUST_BINARIES[@]}"; do
    real_path="$RUST_TOOLCHAIN_PATH/bin/$binary"
    if [[ -x "$real_path" ]]; then
        create_wrapper "$binary" "$real_path"
    else
        echo "Warning: $binary not found at $real_path"
    fi
done

echo ""
echo "Creating GCC toolchain wrappers..."

if [[ -n "$GCC_TOOLCHAIN_PATH" ]]; then
    # GCC binaries to wrap
    GCC_BINARIES=(
        "gcc"
        "g++"
        "cc"
        "c++"
        "cpp"
        "as"
        "ld"
        "ar"
        "ranlib"
        "strip"
        "objcopy"
        "objdump"
        "nm"
        "readelf"
        "size"
    )

    for binary in "${GCC_BINARIES[@]}"; do
        real_path="$GCC_TOOLCHAIN_PATH/bin/$binary"
        if [[ -x "$real_path" ]]; then
            create_wrapper "$binary" "$real_path"
        else
            # Try without wrapper suffix
            for alt_path in /nix/store/*gcc*/bin/$binary; do
                if [[ -x "$alt_path" ]]; then
                    create_wrapper "$binary" "$alt_path"
                    break
                fi
            done
        fi
    done
fi

echo ""
echo "Creating cross-compiler wrappers..."

# Look for cross-compilation tools
for cross_path in /nix/store/*cross*; do
    if [[ -d "$cross_path/bin" ]]; then
        for cross_binary in "$cross_path/bin"/*; do
            if [[ -x "$cross_binary" ]]; then
                binary_name=$(basename "$cross_binary")
                if [[ ! -f "$WRAPPER_DIR/$binary_name" ]]; then
                    create_wrapper "$binary_name" "$cross_binary"
                fi
            fi
        done
    fi
done

echo ""
echo "Creating pkg-config wrapper with enhanced search paths..."

# Find pkg-config
PKG_CONFIG_PATH=""
for path in /nix/store/*pkg-config*/bin/pkg-config; do
    if [[ -x "$path" ]]; then
        PKG_CONFIG_PATH="$path"
        break
    fi
done

if [[ -n "$PKG_CONFIG_PATH" ]]; then
    # Build comprehensive PKG_CONFIG_PATH
    PKG_SEARCH_PATHS=""
    for store_path in /nix/store/*; do
        if [[ -d "$store_path/lib/pkgconfig" ]]; then
            PKG_SEARCH_PATHS="$store_path/lib/pkgconfig:$PKG_SEARCH_PATHS"
        fi
        if [[ -d "$store_path/share/pkgconfig" ]]; then
            PKG_SEARCH_PATHS="$store_path/share/pkgconfig:$PKG_SEARCH_PATHS"
        fi
    done
    PKG_SEARCH_PATHS="${PKG_SEARCH_PATHS%:}"

    create_env_wrapper "pkg-config" "$PKG_CONFIG_PATH" "export PKG_CONFIG_PATH=\"$PKG_SEARCH_PATHS:\${PKG_CONFIG_PATH:-}\""
fi

echo ""
echo "Creating NASM wrapper..."

# Find NASM
for nasm_path in /nix/store/*nasm*/bin/nasm; do
    if [[ -x "$nasm_path" ]]; then
        create_wrapper "nasm" "$nasm_path"
        break
    fi
done

echo ""
echo "Creating make wrapper..."

# Find make
for make_path in /nix/store/*gnumake*/bin/make; do
    if [[ -x "$make_path" ]]; then
        create_wrapper "make" "$make_path"
        break
    fi
done

echo ""
echo "Creating Python3 wrapper..."

# Find Python3
for python_path in /nix/store/*python3*/bin/python3*; do
    if [[ -x "$python_path" && ! "$python_path" =~ -config$ ]]; then
        create_wrapper "python3" "$python_path"
        # Also create python wrapper pointing to python3
        create_wrapper "python" "$python_path"
        break
    fi
done

echo ""
echo "Wrapper creation complete!"
echo ""
echo "Created wrappers in $WRAPPER_DIR:"
ls -la "$WRAPPER_DIR" | grep -v "^total"

echo ""
echo "Library paths configured for wrappers:"
echo "  $LIB_PATHS" | tr ':' '\n' | head -10
echo "  ... (and more)"