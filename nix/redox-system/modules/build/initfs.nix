# RedoxOS Initial RAM Filesystem (initfs)
#
# This module builds the initfs image from configuration.
# It replaces the monolithic nix/pkgs/infrastructure/initfs.nix.
#
# The initfs contains the minimum set of binaries and configuration needed
# to boot Redox OS:
#   - Core daemons (init, logd, ramfs, randd, zerod, pcid, etc.)
#   - Storage and network drivers
#   - The Ion shell
#   - RedoxFS filesystem driver
#   - Configuration files (init.rc, pcid/initfs.toml)
#
# Inputs (from config):
#   - config.redox.boot.kernel: Kernel package
#   - config.redox.boot.initfs.extraBinaries: Additional binaries to include
#   - config.redox.boot.initfs.extraDrivers: Additional drivers to include
#   - config.redox.boot.initfs.enableGraphics: Include graphics support
#   - config.redox.hardware._allDrivers: All enabled drivers
#   - config.redox.hardware._initfsDaemons: Additional daemons (vesad, inputd)
#   - config.redox.hardware._pcidDrivers: PCI ID registry with command field
#
# Output:
#   - system.build.initfs: Initfs image derivation

{
  config,
  lib,
  pkgs,
  hostPkgs,
  redoxSystemLib,
  ...
}:

let
  inherit (lib)
    mkOption
    mkIf
    types
    concatStringsSep
    unique
    optionalString
    ;

  cfg = config.redox.boot.initfs;
  hwCfg = config.redox.hardware;

  # Core daemons that are always included
  # ps2d is only needed for PS/2 keyboard/mouse (graphical mode)
  # smolnetd is only needed when networking is enabled
  coreDaemons = [
    "init"
    "logd"
    "ramfs"
    "randd"
    "zerod"
    "pcid"
    "pcid-spawner"
    "lived"
    "acpid"
    "hwd"
    "rtcd"
    "ptyd"
    "ipcd"
  ]
  ++ lib.optional cfg.enableGraphics "ps2d"
  ++ lib.optional config.redox.networking.enable "smolnetd";

  # All daemons to include (core + hardware-specific)
  allDaemons = unique (coreDaemons ++ hwCfg._initfsDaemons ++ cfg.extraBinaries);

  # All drivers to include
  allDrivers = unique (hwCfg._allDrivers ++ cfg.extraDrivers);

  # Generate PCID driver entry TOML
  # All numeric values are passed as STRINGS containing hex (e.g. "0x1AF4")
  # because Nix doesn't have hex integer literals.
  # Each entry has a `command` field â€” the driver binary name, attached
  # by hardware.nix when building _pcidDrivers from pciDriverRegistry.
  mkPcidDriverEntry =
    {
      name ? null,
      class ? null,
      subclass ? null,
      vendor ? null,
      device ? null,
      command,
    }:
    let
      # Format value for TOML: strings get quoted, hex strings are bare (TOML integers)
      fmtVal =
        v:
        if v == null then
          null
        else if lib.hasPrefix "0x" v then
          v # Hex: emit bare (TOML int literal)
        else if builtins.match "[0-9]+" v != null then
          v # Decimal: emit bare
        else
          ''"${v}"''; # String: quote
      optLine =
        key: val:
        let
          formatted = fmtVal val;
        in
        lib.optionalString (formatted != null) "${key} = ${formatted}\n";
    in
    ''
      [[drivers]]
      ${optLine "name" name}${optLine "class" class}${optLine "subclass" subclass}${optLine "vendor" vendor}${optLine "device" device}command = ["/scheme/initfs/lib/drivers/${command}"]
    '';

  # Generate complete pcid/initfs.toml from hardware registry
  # Each entry in _pcidDrivers has: { name?, class?, subclass?, vendor?, device?, command }
  pcidToml = ''
    # Drivers for InitFS - generated by redox-system
    ${concatStringsSep "\n" (map mkPcidDriverEntry hwCfg._pcidDrivers)}
  '';

  # Find the first non-root user for serial console defaults
  nonRootUsers = lib.filterAttrs (name: user: user.uid > 0) config.redox.users.users;
  defaultUser =
    if nonRootUsers != { } then
      let
        name = builtins.head (builtins.attrNames nonRootUsers);
      in
      {
        inherit name;
        home = nonRootUsers.${name}.home;
      }
    else
      {
        name = "root";
        home = "/root";
      };

  # Generate init.rc boot sequence
  # This matches the current initfs.nix but is driven by config
  initRc = ''
    ${
      if cfg.enableGraphics then
        "# Redox init with graphics support"
      else
        "# Headless Redox init - no graphics support"
    }
    export PATH /scheme/initfs/bin
    export RUST_BACKTRACE 1
    rtcd
    notify nulld
    notify zerod
    notify randd

    # Logging
    notify logd
    stdio /scheme/log
    notify ramfs logging

    # PTY daemon (needed for getty/interactive shells)
    notify ptyd

    ${optionalString cfg.enableGraphics ''
      # Graphics infrastructure
      notify inputd
      notify vesad
      unset FRAMEBUFFER_ADDR FRAMEBUFFER_VIRT FRAMEBUFFER_WIDTH FRAMEBUFFER_HEIGHT FRAMEBUFFER_STRIDE
      notify fbbootlogd
      # Activate framebuffer log VT, which disables kernel graphical debug
      inputd -A 1
      notify fbcond 2
    ''}

    # Live disk (before drivers so it gets priority for disk search)
    notify lived

    # Drivers
    run /scheme/initfs/etc/init_drivers.rc
    unset RSDP_ADDR RSDP_SIZE

    # Mount rootfs
    redoxfs --uuid $REDOXFS_UUID file $REDOXFS_BLOCK
    unset REDOXFS_UUID REDOXFS_BLOCK REDOXFS_PASSWORD_ADDR REDOXFS_PASSWORD_SIZE

    # Exit initfs
    cd /
    export PATH /usr/bin
    unset LD_LIBRARY_PATH
    run.d /usr/lib/init.d /etc/init.d

    # Boot complete
    echo ""
    echo "=========================================="
    echo "  Redox OS Boot Complete!"
    echo "=========================================="
    echo ""

    # Start interactive shell on serial console
    stdio debug:
    export TERM ${config.redox.environment.variables.TERM or "xterm-256color"}
    export XDG_CONFIG_HOME /etc
    export HOME ${defaultUser.home}
    export USER ${defaultUser.name}
    export PATH ${config.redox.environment.variables.PATH or "/bin:/usr/bin"}
    echo "Starting interactive shell on serial console..."
    echo "Type 'help' for commands, 'exit' to quit"
    echo ""
    /bin/ion
  '';

  # Generate init_drivers.rc
  initDriversRc = ''
    ${optionalString cfg.enableGraphics "notify ps2d"}
    notify hwd
    pcid-spawner /scheme/initfs/etc/pcid/initfs.toml
  '';

in
{
  # Use hostPkgs for the build derivation - this runs on the build machine,
  # not on Redox. The cross-compiled binaries (pkgs.base, pkgs.ion) are
  # copied as data, not executed during the build.
  config.system.build.initfs = hostPkgs.stdenv.mkDerivation {
    pname = "redox-initfs";
    version = "unstable";

    dontUnpack = true;

    nativeBuildInputs = [
      pkgs.initfsTools # redox-initfs-ar (host tool)
    ];

    buildPhase = ''
            runHook preBuild

            # Create initfs directory structure
            mkdir -p initfs/bin
            mkdir -p initfs/lib/drivers
            mkdir -p initfs/etc/pcid
            mkdir -p initfs/usr/bin
            mkdir -p initfs/usr/lib/drivers

            # Copy core daemons
            echo "Copying core daemons..."
            ${concatStringsSep "\n" (
              map (daemon: ''
                if [ -f ${pkgs.base}/bin/${daemon} ]; then
                  cp ${pkgs.base}/bin/${daemon} initfs/bin/
                fi
              '') allDaemons
            )}

            # Copy nulld (duplicate of zerod)
            cp ${pkgs.base}/bin/zerod initfs/bin/nulld

            # Copy redoxfs
            cp ${pkgs.redoxfsTarget}/bin/redoxfs initfs/bin/

            # Copy Ion shell
            echo "Copying Ion shell..."
            cp ${pkgs.ion}/bin/ion initfs/bin/
            cp ${pkgs.ion}/bin/ion initfs/usr/bin/
            cp ${pkgs.ion}/bin/ion initfs/bin/sh
            cp ${pkgs.ion}/bin/ion initfs/usr/bin/sh

            # Copy network utilities if available
            ${optionalString (pkgs ? netutils) ''
              if [ -f ${pkgs.netutils}/bin/ifconfig ]; then
                cp ${pkgs.netutils}/bin/ifconfig initfs/bin/
              fi
              if [ -f ${pkgs.netutils}/bin/ping ]; then
                cp ${pkgs.netutils}/bin/ping initfs/bin/
              fi
            ''}

            # Copy userutils (getty, login) if available
            ${optionalString (pkgs ? userutils) ''
              echo "Copying userutils (getty, login)..."
              for bin in getty login; do
                if [ -f ${pkgs.userutils}/bin/$bin ]; then
                  cp ${pkgs.userutils}/bin/$bin initfs/bin/
                fi
              done
            ''}

            # Copy drivers
            echo "Copying drivers: ${concatStringsSep ", " allDrivers}"
            ${concatStringsSep "\n" (
              map (driver: ''
                if [ -f ${pkgs.base}/bin/${driver} ]; then
                  echo "  ${driver}"
                  cp ${pkgs.base}/bin/${driver} initfs/lib/drivers/
                else
                  echo "  WARNING: ${driver} not found"
                fi
              '') allDrivers
            )}

            # Copy USB drivers to multiple locations if USB enabled
            ${optionalString config.redox.hardware.usb.enable ''
              echo "Copying USB stack..."
              for drv in xhcid usbhubd usbhidd; do
                if [ -f ${pkgs.base}/bin/$drv ]; then
                  cp ${pkgs.base}/bin/$drv initfs/lib/drivers/
                fi
              done
              # Also copy to bin and /usr/lib/drivers
              for bin in usbhubd usbhidd; do
                if [ -f ${pkgs.base}/bin/$bin ]; then
                  cp ${pkgs.base}/bin/$bin initfs/bin/
                  cp ${pkgs.base}/bin/$bin initfs/usr/lib/drivers/
                fi
              done
            ''}

            echo "=== Drivers in initfs/lib/drivers ==="
            ls -la initfs/lib/drivers/

            # Write pcid/initfs.toml (must NOT be indented - TOML is whitespace-sensitive)
            cat > initfs/etc/pcid/initfs.toml << 'PCID_EOF'
      ${pcidToml}
      PCID_EOF

            # Write init.rc (must NOT be indented - init.rc format is line-by-line)
            cat > initfs/etc/init.rc << 'INITRC_EOF'
      ${initRc}
      INITRC_EOF

            # Write init_drivers.rc
            cat > initfs/etc/init_drivers.rc << 'DRIVERS_EOF'
      ${initDriversRc}
      DRIVERS_EOF

            # Create Ion shell configuration
            mkdir -p initfs/etc/ion
            echo '# Simple Ion shell configuration for headless Redox' > initfs/etc/ion/initrc
            echo '# Use a simple prompt without subprocess expansion' >> initfs/etc/ion/initrc
            echo 'let PROMPT = "ion> "' >> initfs/etc/ion/initrc

            # Create initfs image
            echo "Creating initfs image with redox-initfs-ar..."
            redox-initfs-ar initfs ${pkgs.bootstrap}/bin/bootstrap -o initfs.img

            runHook postBuild
    '';

    installPhase = ''
      runHook preInstall
      mkdir -p $out/boot
      cp initfs.img $out/boot/initfs
      runHook postInstall
    '';

    meta = with lib; {
      description = "Redox initial RAM filesystem";
      license = licenses.mit;
    };
  };
}
